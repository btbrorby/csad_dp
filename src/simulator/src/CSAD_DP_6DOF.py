#!/usr/bin/env python

from email.utils import decode_rfc2231
import math
import random
from re import M
from tkinter import W
import generateModelData_CSAD as data
from nav_msgs.msg import Odometry
from std_msgs.msg import Float32MultiArray
import rospy
import numpy as np
import math_tools
import scipy

#Time step for simulation
dt = 0.01

class CSAD:
    
    
    def __init__(self, eta0):
        #Initialzing states
        self.eta = eta0
        self.nu = np.zeros(6)
        self.bias = np.zeros(6)
        self.eta_dot = np.zeros(6)
        self.nu_dot = np.zeros(6)
        self.bias_dot = np.zeros(6)
        
        self.T_b = np.zeros(6)  # Tuning bias
        self.biasMean = 0.0     # Defining white noise
        self.biasStd = 1.0      # Defining white noise
        
        #Initionalize thrust dynamics
        self.u = np.zeros(12)
        self.thrustDynamics = ThrusterDynamics(self.u)
        
        #ROS communication related:
        self.odometry_msg = Odometry()
        self.odometry_msg.header.frame_id = "odometry"
        
        #Simulates the published qualisys node generated by the simulation model:
        self.pub_odometry = rospy.Publisher('/CSAD/simulator', Odometry, queue_size=1)
        
        #Subscribes on the u vector from thrust allocation: 
        self.sub_u = rospy.Subscriber('/CSAD/u', Float32MultiArray, queue_size=1)
        
        
    
    
    def nav_msg(self):
        quaternion = math_tools.euler2quat(self.eta[3], self.eta[4], self.eta[5])
        self.odometry_msg.pose.pose.position.x = self.eta[0]
        self.odometry_msg.pose.pose.position.y = self.eta[1]
        self.odometry_msg.pose.pose.position.z = self.eta[2]
        self.odometry_msg.pose.pose.orientation.x = quaternion[0]
        self.odometry_msg.pose.pose.orientation.y = quaternion[1]
        self.odometry_msg.pose.pose.orientation.z = quaternion[2]
        self.odometry_msg.pose.pose.orientation.w = quaternion[3]
        
        self.odometry_msg.twist.twist.linear.x = self.nu[0]
        self.odometry_msg.twist.twist.linear.y = self.nu[1]
        self.odometry_msg.twist.twist.linear.z = self.nu[2]
        self.odometry_msg.twist.twist.angular.x = self.nu[3]
        self.odometry_msg.twist.twist.angular.y = self.nu[4]
        self.odometry_msg.twist.twist.angular.z = self.nu[5]
        
    def setD(self, nu):
        """
        Calculates the damping matrix as function of nu.

        Args:
            nu (array): body fixed velocity

        Returns:
            Array: Damping matrix (6DOF), but currrently only surge, sway and yaw directions are calculated. This is due to restricted available data.
        """
        u = nu[0]
        v = nu[1]
        w = nu[2]
        p = nu[3]
        q = nu[4]
        r = nu[5]
        
        d11 = data.Xu + data.Xuu*np.abs(u) + data.Xuuu*(u**2)
        d22 = data.Yv + data.Yvv*np.abs(v) + data.Yvvv*(v**2) + data.Yrv*np.abs(r)
        d26 = data.Yr + data.Yvr*np.abs(v) + data.Yrr*np.abs(r) + data.Yrrr*(r**2)
        d62 = data.Nv + data.Nvv*np.abs(v) + data.Nvvv*(v**2) + data.Nrv*np.abs(r)
        d66 = data.Nr + data.Nvr*np.abs(v) + data.Nrr*np.abs(r) + data.Nrrr*(r**2)
        
        D = np.zeros([6, 6])
        D[0][0] = -d11
        D[1][1] = -d22
        D[1][5] = -d26
        D[5][1] = -d62
        D[5][5] = -d66
        
        return D
        
        
    # def setC(self):
        
        
    def updateStates(self, tauEnv, tauThr):
        """
        Based on the following model:
        M_RB*nu_dot + M_a*nu_dot + C_RB(nu)*nu + C_A(nu_r)*nu_r + D(nu_r)*nu_r = tau_env + tau_thr
        
        But since this is a LF model, we can neglect the Coriolis and centripetal terms (very small).
        
        eta_dot = J(eta)*nu
        bias_dot = -T_b*bias + w_b
        M*nu_dot = -D_lin*nu +J(eta)^T * bias + tau_thr + tau_wave2
        
        According to Bjoernoe's OMAE paper, the bias includes also wave2, but we want this to be reflected by incomming waves!

        Returns:
            _type_: _description_
        """
        J = math_tools.transformationMatrix(self.eta)
        self.eta_dot = np.matmul(J, self.nu)
        
        noise = np.random.normal(self.biasMean, self.biasStd, 6)
        self.bias_dot = np.matmul(-self.T_b,self.bias) + noise
        
        M = data.MRB + data.MA
        Minv = np.linalg.inv(M)
        D = self.setD(self.nu)
        
        self.nu_dot = np.matmul(Minv, np.matmul(-D, self.nu) + np.matmul(np.transpose(J), self.bias) + tauEnv + tauThr)
        
        # Euler integration:
        self.eta += self.eta_dot*dt
        self.eta[5] = math_tools.ssa(self.eta[5])
        self.nu += self.nu_dot*dt
        self.bias += self.bias_dot*dt
        
        
        
        return 0
    
    
        
        
        
      
#This class should maybe be in separate python file?
class ThrusterDynamics:
    def __init__(self, u):
        #Initialize thruster dynamics
        self.loads = np.zeros(6)
        self.u = u[0:6]
        self.alpha = u[5:12]
        self.n = np.zeros(6)
        
        self.alpha_previous = np.zeros(6)
        self.n_previous = np.zeros(6)
        
        #Thruster konfiguration
        self.Lx = data.Lx
        self.Ly = data.Ly
        self.K = data.K
        
        #Limitations and saturations
        self.alpha_dot_max = data.alpha_dot_max
        self.n_dot_max = data.n_dot_max
        
        
    def actualThrustLoads(self, u, alpha):
        """
        Calcluates the actual load generated by the azimuth thrusters in body frame.
        The thrust dynamics are saturated and the rates are limited.
        Calculates the load from each actuator by F_i=rho*D^4*K_T*abs(n)*n
        Returns:
            self.loads: Actual thrust loads (body frame) generated by the resulting loads from all actuators.
        """
        
        #Calculates the propeller revolution based on desired actuator inputs:
        n = self.propellerRevolution(u)
        
        #Limits the signal rates based on specified limitations:
        alpha_actual = self.rateLimiter(alpha, self.alpha_previous, self.alpha_dot_max)
        n_actual = self.rateLimiter(n, self.n_previous, self.n_dot_max)
        
        #Calculates the actual actuator loads for each actuator:
        actuatorLoads = data.rho*(data.propellerDiameter**4)*(data.K * np.abs(n) * n)
        
        #Saturates the actuator loads based on specified limitations:
        actuatorLoads = self.saturate(actuatorLoads, -data.thrust_max, data.thrust_max)
        
        #Summerize contributions from each eactuator and converts them to specific loads in body frame:
        loads = np.zeros(6)
        for i in range(np.size(actuatorLoads)):
            loads[0] = loads[0] + actuatorLoads[i]*math.cos(alpha[i])
            loads[1] = loads[1] + actuatorLoads[i]*math.sin(alpha[i])
            loads[5] = loads[5] + data.Lx[i]*actuatorLoads[i]*math.sin(alpha[i]) - data.Ly*actuatorLoads[i]*math.cos(alpha[i])
        
        #Stores previous signals. Used for limit the signal rates:
        self.alpha_previous = alpha_actual #Sould this be called where the function is called?
        self.n_previous = n #Sould this be called where the function is called?
        
        return loads, n_actual, alpha_actual
    
    def propellerRevolution(self, u):
        n = math_tools.sign(u)*math.sqrt(np.abs(u))
        return n
        
    def saturate(self, signal, min, max):
        if signal < min:
            signal = min
        elif signal > max:
            signal = max
        return signal
    
    def rateLimiter(self, signal, signalPrevious, limit):
        """
        Limits the rates of the signal.

        Args:
            signal (_type_): The signal that needs to be limited
            signalPrevious (_type_): A copy of the previous signal
            limit (_type_): The specified rate limit
        """
        plussMinus = math_tools.sign(signal-signalPrevious) #negative if signal is decreasing, positiv if increasing
        if np.abs((signal - signalPrevious)/dt) > limit:
            signal = signalPrevious + plussMinus*limit*dt
        
        return signal    
    
    # Implement a low pass filter for smoothing thrust dynamics (angle shift and setpoint shift).
    # n_dot <= 5 [1/s^2] propeller acceleration 5 revolutions pr s^2
    # alpha_dot <= 2 [1/s] propeller rotation speed
    # Saturate min and max values of thrust (max thrust is 1.5[N])
        



def loop():
    return 0
