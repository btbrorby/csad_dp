#!/usr/bin/env python
import math
import generateModelData_CSAD as data
from nav_msgs.msg import Odometry
from std_msgs.msg import Float32MultiArray
import rospy
import numpy as np
import math_tools
import scipy

#Time step for simulation
dt = 0.01

class CSAD:
    
    
    def __init__(self, eta0):
        #Initialzing states
        self.eta = eta0
        self.nu = np.zeros(6)
        self.eta_dot = np.zeros(6)
        self.nu_dot = np.zeros(6)
        
        #Initionalize thrust dynamics
        self.u = np.zeros(12)
        self.thrustDynamics = ThrusterDynamics(self.u)
        
        #ROS communication related:
        self.odometry_msg = Odometry()
        self.odometry_msg.header.frame_id = "odometry"
        
        #Simulates the published qualisys node generated by the simulation model:
        self.pub_odometry = rospy.Publisher('/qualisys/Body_1/odom', Odometry, queue_size=1)
        
        #Subscribes on the u vector from thrust allocation: 
        self.sub_u = rospy.Subscriber('/CSAD/u', Float32MultiArray, queue_size=1)
        
        
    
    
    def nav_msg(self):
        quaternion = math_tools.euler2quat(self.eta[3], self.eta[4], self.eta[5])
        self.odometry_msg.pose.pose.position.x = self.eta[0]
        self.odometry_msg.pose.pose.position.y = self.eta[1]
        self.odometry_msg.pose.pose.position.z = self.eta[2]
        self.odometry_msg.pose.pose.orientation.x = quaternion[0]
        self.odometry_msg.pose.pose.orientation.y = quaternion[1]
        self.odometry_msg.pose.pose.orientation.z = quaternion[2]
        self.odometry_msg.pose.pose.orientation.w = quaternion[3]
        
        self.odometry_msg.twist.twist.linear.x = self.nu[0]
        self.odometry_msg.twist.twist.linear.y = self.nu[1]
        self.odometry_msg.twist.twist.linear.z = self.nu[2]
        self.odometry_msg.twist.twist.angular.x = self.nu[3]
        self.odometry_msg.twist.twist.angular.y = self.nu[4]
        self.odometry_msg.twist.twist.angular.z = self.nu[5]
        
      
#This class should maybe be in separate python file?
class ThrusterDynamics:
    def __init__(self, u):
        #Initialize thruster dynamics
        self.loads = np.zeros(6)
        self.u = u[0:6]
        self.alpha = u[5:12]
        self.n = np.zeros(6)
        
        self.alpha_previous = np.zeros(6)
        self.n_previous = np.zeros(6)
        
        #Thruster konfiguration
        self.Lx = data.Lx
        self.Ly = data.Ly
        self.K = data.K
        
        #Limitations and saturations
        self.alpha_dot_max = data.alpha_dot_max
        self.n_dot_max = data.n_dot_max
        
        
    def actualThrustLoads(self, u, alpha):
        """
        Calcluates the actual load generated by the azimuth thrusters in body frame.
        The thrust dynamics are saturated and the rates are limited.
        Calculates the load from each actuator by F_i=rho*D^4*K_T*abs(n)*n
        Returns:
            self.loads: Actual thrust loads (body frame) generated by the resulting loads from all actuators.
        """
        
        #Calculates the propeller revolution based on desired actuator inputs:
        n = self.propellerRevolution(u)
        
        #Limits the signal rates based on specified limitations:
        alpha_actual = self.rateLimiter(alpha, self.alpha_previous, self.alpha_dot_max)
        n_actual = self.rateLimiter(n, self.n_previous, self.n_dot_max)
        
        #Calculates the actual actuator loads for each actuator:
        actuatorLoads = data.rho*(data.propellerDiameter**4)*(data.K * np.abs(n) * n)
        
        #Saturates the actuator loads based on specified limitations:
        actuatorLoads = self.saturate(actuatorLoads, -data.thrust_max, data.thrust_max)
        
        #Summerize contributions from each eactuator and converts them to specific loads in body frame:
        loads = np.zeros(6)
        for i in range(np.size(actuatorLoads)):
            loads[0] = loads[0] + actuatorLoads[i]*math.cos(alpha[i])
            loads[1] = loads[1] + actuatorLoads[i]*math.sin(alpha[i])
            loads[5] = loads[5] + data.Lx[i]*actuatorLoads[i]*math.sin(alpha[i]) - data.Ly*actuatorLoads[i]*math.cos(alpha[i])
        
        #Stores previous signals. Used for limit the signal rates:
        self.alpha_previous = alpha_actual #Sould this be called where the function is called?
        self.n_previous = n #Sould this be called where the function is called?
        
        return loads, n_actual, alpha_actual
    
    def propellerRevolution(self, u):
        n = math_tools.sign(u)*math.sqrt(np.abs(u))
        return n
        
    def saturate(self, signal, min, max):
        if signal < min:
            signal = min
        elif signal > max:
            signal = max
        return signal
    
    def rateLimiter(self, signal, signalPrevious, limit):
        """
        Limits the rates of the signal.

        Args:
            signal (_type_): The signal that needs to be limited
            signalPrevious (_type_): A copy of the previous signal
            limit (_type_): The specified rate limit
        """
        plussMinus = math_tools.sign(signal-signalPrevious) #negative if signal is decreasing, positiv if increasing
        if np.abs((signal - signalPrevious)/dt) > limit:
            signal = signalPrevious + plussMinus*limit*dt
        
        return signal    
    
    # Implement a low pass filter for smoothing thrust dynamics (angle shift and setpoint shift).
    # n_dot <= 5 [1/s^2] propeller acceleration 5 revolutions pr s^2
    # alpha_dot <= 2 [1/s] propeller rotation speed
    # Saturate min and max values of thrust (max thrust is 1.5[N])
        
  



def loop():
    return 0
