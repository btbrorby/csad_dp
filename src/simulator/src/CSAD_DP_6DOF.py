#!/usr/bin/env python
import generateModelData_CSAD as data
from waveLoads import Wave
import math_tools

from nav_msgs.msg import Odometry
from std_msgs.msg import Float64MultiArray
from ThrusterDynamics import ThrusterDynamics
import rospy
import numpy as np
from matplotlib import pyplot
from mpl_toolkits import mplot3d
import time
import os
import yaml



class CSAD:
    
    
    def __init__(self, eta0, dt=0.02):
        self.dt = dt
        self.time = 0.0
        self.RAOForce = data.RAO_FORCE
        #Initialzing states
        self.eta = eta0
        self.nu = np.zeros([6,1])
        
        self.bias = np.zeros([6,1])
        self.eta_dot = np.zeros([6,1])
        self.nu_dot = np.zeros([6,1])
        self.bias_dot = np.zeros([6,1])
        
        self.T_b = (1000.0/90.0)*np.eye(6)   # Tuning bias 2~3 times larger than the wave period(?) Make function for this!
        self.biasMean = 0.0     # Defining white noise
        self.biasStd = 0.01      # Defining white noise
        
        #Initionalize thrust dynamics
        self.u = np.zeros([12,1])
        self.thrustDynamics = ThrusterDynamics(self.u)
        
        #ROS communication related:
        self.odometry_msg = Odometry()
        self.odometry_msg.header.frame_id = 'odometry'
        
        #Simulates the published qualisys node generated by the simulation model:
        self.pub_odometry = rospy.Publisher('/qualisys/Body_1/odom', Odometry, queue_size=1)
        
        #Subscribes on the u vector from thrust allocation: 
        self.sub_u = rospy.Subscriber('/CSAD/u', Float64MultiArray, queue_size=1)
        
        
        
    def publish(self):
        quaternion = math_tools.euler2quat(self.eta[3][0], self.eta[4][0], self.eta[5][0])
        self.odometry_msg.pose.pose.position.x = self.eta[0][0]
        self.odometry_msg.pose.pose.position.y = self.eta[1][0]
        self.odometry_msg.pose.pose.position.z = self.eta[2][0]
        self.odometry_msg.pose.pose.orientation.x = quaternion[0]
        self.odometry_msg.pose.pose.orientation.y = quaternion[1]
        self.odometry_msg.pose.pose.orientation.z = quaternion[2]
        self.odometry_msg.pose.pose.orientation.w = quaternion[3]
        
        self.odometry_msg.twist.twist.linear.x = self.nu[0][0]
        self.odometry_msg.twist.twist.linear.y = self.nu[1][0]
        self.odometry_msg.twist.twist.linear.z = self.nu[2][0]
        self.odometry_msg.twist.twist.angular.x = self.nu[3][0]
        self.odometry_msg.twist.twist.angular.y = self.nu[4][0]
        self.odometry_msg.twist.twist.angular.z = self.nu[5][0]
        self.odometry_msg.header.frame_id = 'simulator'
        # d = rospy.Duration(self.time)
        # print("sec", d.to_sec())
        # print("nsec", d.to_nsec())
        self.odometry_msg.header.stamp = rospy.Time.now()
        # self.odometry_msg.header.stamp.secs = d.to_sec()
        # self.odometry_msg.header.stamp.nsecs = d.to_nsec()
        
        self.pub_odometry.publish(self.odometry_msg)
    
    
    def nav_msg(self):
        quaternion = math_tools.euler2quat(self.eta[3], self.eta[4], self.eta[5])
        self.odometry_msg.pose.pose.position.x = self.eta[0]
        self.odometry_msg.pose.pose.position.y = self.eta[1]
        self.odometry_msg.pose.pose.position.z = self.eta[2]
        self.odometry_msg.pose.pose.orientation.x = quaternion[0]
        self.odometry_msg.pose.pose.orientation.y = quaternion[1]
        self.odometry_msg.pose.pose.orientation.z = quaternion[2]
        self.odometry_msg.pose.pose.orientation.w = quaternion[3]
        
        self.odometry_msg.twist.twist.linear.x = self.nu[0]
        self.odometry_msg.twist.twist.linear.y = self.nu[1]
        self.odometry_msg.twist.twist.linear.z = self.nu[2]
        self.odometry_msg.twist.twist.angular.x = self.nu[3]
        self.odometry_msg.twist.twist.angular.y = self.nu[4]
        self.odometry_msg.twist.twist.angular.z = self.nu[5]
        
        
        
    # def getC(self):
        
    def updateStates(self, tauEnv, tauThr, waveFreq):
        """
        Update states for the vessel, with parameters based on different frequencies achieved from experiments (Bjornoe).
        Note that Waves.setHeading() have to be called after calling this function.
        """
        
        tauEnv = np.resize(tauEnv, (6,1))
        tauThr = np.resize(tauThr, (6,1))
        index = np.argmin(np.abs(data.frequencies - waveFreq)) #Should probably be a interpolation instead...
        A = data.A[:,:,index]   #Added mass
        B = data.B[:,:,index]   #Potential + viscous damping
        C = data.C[:,:,index]   #Restoring forces
        # B[3, 3] *= 10.0
        
        M = A + data.MRB
        B[3,3] = 2.0*np.sqrt(M[3,3]*C[3,3])*0.1
        Minv = np.linalg.inv(M)
        
        J = math_tools.transformationMatrix(self.eta)
        Jinv = np.linalg.inv(J)
        
        self.eta_dot = np.matmul(J, self.nu)
        self.eta_dot = self.eta_dot.astype(float)
        
        noise = np.random.normal(self.biasMean, self.biasStd, 6)
        noise = np.resize(noise, (6,1))
        
        self.bias_dot = np.matmul(-np.linalg.inv(self.T_b), self.bias)# + noise
        self.bias_dot = self.bias_dot.astype(float)
        
        self.nu_dot = np.matmul(Minv, np.matmul(-B, self.nu) + np.matmul(-C, self.eta) + np.matmul(Jinv, self.bias) + tauEnv + tauThr)
        self.nu_dot = self.nu_dot.astype(float)
        
        # Euler integration:
        self.eta += self.eta_dot*self.dt
        self.eta[5] = math_tools.ssa(self.eta[5])
        self.nu += self.nu_dot*self.dt
        self.bias += self.bias_dot*self.dt
        
        self.eta = self.eta.astype(float)
        self.nu = self.nu.astype(float)
        self.bias = self.bias.astype(float)

        self.time += self.dt
        